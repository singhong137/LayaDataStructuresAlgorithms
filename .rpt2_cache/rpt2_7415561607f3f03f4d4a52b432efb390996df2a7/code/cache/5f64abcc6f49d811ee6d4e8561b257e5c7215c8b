{
  "code": "import { TreeNode, RedBlackNode, Colors } from \"./data_models/Node\";\r\nimport { defaultCompare, Compare } from \"../util\";\r\nexport class BinarySearchTree {\r\n    constructor(compareFn = defaultCompare) {\r\n        this.compareFn = compareFn;\r\n    }\r\n    insert(key) {\r\n        if (this.root == null) {\r\n            this.root = new TreeNode(key);\r\n        }\r\n        else {\r\n            this.insertNode(this.root, key);\r\n        }\r\n    }\r\n    insertNode(node, key) {\r\n        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            if (node.left == null) {\r\n                node.left = new TreeNode(key);\r\n            }\r\n            else {\r\n                this.insertNode(node.left, key);\r\n            }\r\n        }\r\n        else if (node.right == null) {\r\n            node.right = new TreeNode(key);\r\n        }\r\n        else {\r\n            this.insertNode(node.right, key);\r\n        }\r\n    }\r\n    getRoot() {\r\n        return this.root;\r\n    }\r\n    search(key) {\r\n        return this.searchNode(this.root, key);\r\n    }\r\n    searchNode(node, key) {\r\n        if (node == null)\r\n            return false;\r\n        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            return this.searchNode(node.left, key);\r\n        }\r\n        else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n            return this.searchNode(node.right, key);\r\n        }\r\n        return true;\r\n    }\r\n    inOrderTraverse(callback) {\r\n        this.inOrderTraverseNode(this.root, callback);\r\n    }\r\n    inOrderTraverseNode(node, callback) {\r\n        if (node != null) {\r\n            this.inOrderTraverseNode(node.left, callback);\r\n            callback(node.key);\r\n            this.inOrderTraverseNode(node.right, callback);\r\n        }\r\n    }\r\n    preOrderTraverse(callback) {\r\n        this.preOrderTraverseNode(this.root, callback);\r\n    }\r\n    preOrderTraverseNode(node, callback) {\r\n        if (node != null) {\r\n            callback(node.key);\r\n            this.preOrderTraverseNode(node.left, callback);\r\n            this.preOrderTraverseNode(node.right, callback);\r\n        }\r\n    }\r\n    postOrderTraverse(callback) {\r\n        this.postOrderTraverseNode(this.root, callback);\r\n    }\r\n    postOrderTraverseNode(node, callback) {\r\n        if (node != null) {\r\n            this.postOrderTraverseNode(node.left, callback);\r\n            this.postOrderTraverseNode(node.right, callback);\r\n            callback(node.key);\r\n        }\r\n    }\r\n    min() {\r\n        return this.minNode(this.root);\r\n    }\r\n    minNode(node) {\r\n        let current = node;\r\n        while (current != null && current.left != null)\r\n            current = current.left;\r\n        return current;\r\n    }\r\n    max() {\r\n        return this.maxNode(this.root);\r\n    }\r\n    maxNode(node) {\r\n        let current = node;\r\n        while (current != null && current.right != null)\r\n            current = current.right;\r\n        return current;\r\n    }\r\n    remove(key) {\r\n        return this.root = this.removeNode(this.root, key);\r\n    }\r\n    removeNode(node, key) {\r\n        if (node == null)\r\n            return null;\r\n        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            node.left = this.removeNode(node.left, key);\r\n            return node;\r\n        }\r\n        else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n            node.right = this.removeNode(node.right, key);\r\n            return node;\r\n        }\r\n        else {\r\n            if (node.left == null && node.right == null) {\r\n                node = null;\r\n                return node;\r\n            }\r\n            if (node.left == null) {\r\n                node = node.right;\r\n                return node;\r\n            }\r\n            else if (node.right == null) {\r\n                node = node.left;\r\n                return node;\r\n            }\r\n            const aux = this.minNode(node.right);\r\n            node.key = aux.key;\r\n            node.right = this.removeNode(node.right, aux.key);\r\n            return node;\r\n        }\r\n    }\r\n}\r\nvar BalanceFactor;\r\n(function (BalanceFactor) {\r\n    BalanceFactor[BalanceFactor[\"UNBALANCED_RIGHT\"] = 1] = \"UNBALANCED_RIGHT\";\r\n    BalanceFactor[BalanceFactor[\"SLIGHTLY_UNBALANCED_RIGHT\"] = 2] = \"SLIGHTLY_UNBALANCED_RIGHT\";\r\n    BalanceFactor[BalanceFactor[\"BALANCED\"] = 3] = \"BALANCED\";\r\n    BalanceFactor[BalanceFactor[\"SLIGHTLY_UNBALANCED_LEFT\"] = 4] = \"SLIGHTLY_UNBALANCED_LEFT\";\r\n    BalanceFactor[BalanceFactor[\"UNBALANCED_LEFT\"] = 5] = \"UNBALANCED_LEFT\";\r\n})(BalanceFactor || (BalanceFactor = {}));\r\nexport class AVLTree extends BinarySearchTree {\r\n    constructor(compareFn = defaultCompare) {\r\n        super(compareFn);\r\n        this.compareFn = compareFn;\r\n    }\r\n    getNodeHeight(node) {\r\n        if (node == null)\r\n            return -1;\r\n        return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;\r\n    }\r\n    rotationLL(node) {\r\n        const tmp = node.left;\r\n        node.left = tmp.right;\r\n        tmp.right = node;\r\n        return tmp;\r\n    }\r\n    rotationRR(node) {\r\n        const tmp = node.right;\r\n        node.right = tmp.left;\r\n        tmp.left = node;\r\n        return tmp;\r\n    }\r\n    rotationLR(node) {\r\n        node.left = this.rotationRR(node.left);\r\n        return this.rotationLL(node);\r\n    }\r\n    rotationRL(node) {\r\n        node.right = this.rotationLL(node.right);\r\n        return this.rotationRR(node);\r\n    }\r\n    getBalanceFactor(node) {\r\n        const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\r\n        switch (heightDifference) {\r\n            case -2: return BalanceFactor.UNBALANCED_RIGHT;\r\n            case -1: return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;\r\n            case 1: return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;\r\n            case 2: return BalanceFactor.UNBALANCED_LEFT;\r\n            default: return BalanceFactor.BALANCED;\r\n        }\r\n    }\r\n    insert(key) {\r\n        this.root = this.insertNode(this.root, key);\r\n    }\r\n    insertNode(node, key) {\r\n        if (node == null) {\r\n            return new TreeNode(key);\r\n        }\r\n        else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            node.left = this.insertNode(node.left, key);\r\n        }\r\n        else if (this.compareFn(key, node.key) == Compare.BIGGER_THAN) {\r\n            node.right = this.insertNode(node.right, key);\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n        const balanceState = this.getBalanceFactor(node);\r\n        if (balanceState === BalanceFactor.UNBALANCED_LEFT) {\r\n            if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {\r\n                node = this.rotationLL(node);\r\n            }\r\n            else {\r\n                return this.rotationLR(node);\r\n            }\r\n        }\r\n        if (balanceState === BalanceFactor.UNBALANCED_RIGHT) {\r\n            if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {\r\n                node = this.rotationRR(node);\r\n            }\r\n            else {\r\n                return this.rotationRL(node);\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    removeNode(node, key) {\r\n        if (node == null)\r\n            return null;\r\n        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            node.left = this.removeNode(node.left, key);\r\n        }\r\n        else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {\r\n            node.right = this.removeNode(node.right, key);\r\n        }\r\n        else {\r\n            if (node.left == null && node.right == null) {\r\n                node = null;\r\n            }\r\n            else if (node.left == null && node.right != null) {\r\n                node = node.right;\r\n            }\r\n            else if (node.left != null && node.right == null) {\r\n                node = node.left;\r\n            }\r\n            else {\r\n                const inOrderSuccessor = this.minNode(node.right);\r\n                node.key = inOrderSuccessor.key;\r\n                node.right = this.removeNode(node.right, inOrderSuccessor.key);\r\n            }\r\n        }\r\n        if (node == null)\r\n            return node;\r\n        const balanceState = this.getBalanceFactor(node);\r\n        if (balanceState === BalanceFactor.UNBALANCED_LEFT) {\r\n            if (this.getBalanceFactor(node.left) === BalanceFactor.BALANCED || this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\r\n                return this.rotationLL(node);\r\n            }\r\n            if (this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\r\n                return this.rotationLR(node.left);\r\n            }\r\n        }\r\n        if (balanceState === BalanceFactor.UNBALANCED_RIGHT) {\r\n            if (this.getBalanceFactor(node.right) === BalanceFactor.BALANCED || this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\r\n                return this.rotationRR(node);\r\n            }\r\n            if (this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\r\n                return this.rotationRL(node.right);\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n}\r\nexport class RedBlackTree extends BinarySearchTree {\r\n    constructor(compareFn = defaultCompare) {\r\n        super();\r\n        this.compareFn = compareFn;\r\n    }\r\n    rotationLL(node) {\r\n        const tmp = node.left;\r\n        node.left = tmp.right;\r\n        if (tmp.right && tmp.right.key)\r\n            tmp.right.parent = node;\r\n        tmp.parent = node.parent;\r\n        if (!node.parent) {\r\n            this.root = tmp;\r\n        }\r\n        else {\r\n            if (node === node.parent.left) {\r\n                node.parent.left = tmp;\r\n            }\r\n            else {\r\n                node.parent.right = tmp;\r\n            }\r\n        }\r\n        tmp.right = node;\r\n        node.parent = tmp;\r\n    }\r\n    rotationRR(node) {\r\n        const tmp = node.right;\r\n        node.right = tmp.left;\r\n        if (tmp.left && tmp.left.key)\r\n            tmp.left.parent = node;\r\n        tmp.parent = node.parent;\r\n        if (!node.parent) {\r\n            this.root = tmp;\r\n        }\r\n        else {\r\n            if (node === node.parent.left) {\r\n                node.parent.left = tmp;\r\n            }\r\n            else {\r\n                node.parent.right = tmp;\r\n            }\r\n        }\r\n        tmp.left = node;\r\n        node.parent = tmp;\r\n    }\r\n    insert(key) {\r\n        if (this.root == null) {\r\n            this.root = new RedBlackNode(key);\r\n            this.root.color = Colors.BLACK;\r\n        }\r\n        else {\r\n            const newNode = this.insertNode(this.root, key);\r\n            this.fixTreeProperties(newNode);\r\n        }\r\n    }\r\n    insertNode(node, key) {\r\n        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {\r\n            if (node.left == null) {\r\n                node.left = new RedBlackNode(key);\r\n                node.left.parent = node;\r\n                return node.left;\r\n            }\r\n            else {\r\n                return this.insertNode(node.left, key);\r\n            }\r\n        }\r\n        else if (node.right == null) {\r\n            node.right = new RedBlackNode(key);\r\n            node.right.parent = node;\r\n            return node.right;\r\n        }\r\n        else {\r\n            return this.insertNode(node.right, key);\r\n        }\r\n    }\r\n    fixTreeProperties(node) {\r\n        while (node && node.parent && node.parent.color === Colors.RED && node.color !== Colors.BLACK) {\r\n            let parent = node.parent;\r\n            const grandParent = parent.parent;\r\n            if (grandParent && grandParent.left === parent) {\r\n                const uncle = grandParent.right;\r\n                if (uncle && uncle.color === Colors.RED) {\r\n                    grandParent.color = Colors.RED;\r\n                    uncle.color = Colors.BLACK;\r\n                    node = grandParent;\r\n                }\r\n                else {\r\n                    if (node === parent.right) {\r\n                        this.rotationRR(parent);\r\n                        node = parent;\r\n                        parent = node.parent;\r\n                    }\r\n                    this.rotationLL(grandParent);\r\n                    parent.color = Colors.BLACK;\r\n                    grandParent.color = Colors.RED;\r\n                    node = parent;\r\n                }\r\n            }\r\n            else {\r\n                const uncle = grandParent.left;\r\n                if (uncle && uncle.color === Colors.RED) {\r\n                    grandParent.color = Colors.RED;\r\n                    parent.color = Colors.BLACK;\r\n                    uncle.color = Colors.BLACK;\r\n                    node = grandParent;\r\n                }\r\n                else {\r\n                    if (node === parent.left) {\r\n                        this.rotationLL(parent);\r\n                        node = parent;\r\n                        parent = node.parent;\r\n                    }\r\n                    this.rotationRR(grandParent);\r\n                    parent.color = Colors.BLACK;\r\n                    grandParent.color = Colors.RED;\r\n                    node = parent;\r\n                }\r\n            }\r\n        }\r\n        this.root.color = Colors.BLACK;\r\n    }\r\n    getRoot() {\r\n        return this.root;\r\n    }\r\n}\r\n",
  "references": [
    "D:/widgets/LayaDataStructuresAlgorithms/src/data_structures/data_models/Node.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/util.ts"
  ]
}
