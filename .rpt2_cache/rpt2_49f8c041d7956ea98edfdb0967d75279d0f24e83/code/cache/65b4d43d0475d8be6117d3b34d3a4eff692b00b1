{
  "code": "import { Laya } from \"Laya\";\r\nimport { Script } from \"laya/components/Script\";\r\nimport { BFS, breadthFirstSearch } from \"../algorithms/graph/breadth-first-search\";\r\nimport { depthFirstSearch, DFS } from \"../algorithms/graph/depth-first-search\";\r\nimport { dijkstra, dijkstraWithPath } from \"../algorithms/graph/dijkstra\";\r\nimport { floydWarshall, floydWarshallWithPath } from \"../algorithms/graph/Floyd-warshall\";\r\nimport { prim } from \"../algorithms/graph/prim\";\r\nimport Graph from \"../data_structures/Graph\";\r\nimport { Stack } from \"../data_structures/Stack\";\r\nexport default class GraphTest extends Script {\r\n    constructor() {\r\n        super();\r\n    }\r\n    onEnable() {\r\n        console.log('GraphTest---');\r\n        let graph = new Graph();\r\n        let myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\r\n        for (let i = 0; i < myVertices.length; i++)\r\n            graph.addVertex(myVertices[i]);\r\n        graph.addEdge('A', 'B');\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('C', 'D');\r\n        graph.addEdge('C', 'G');\r\n        graph.addEdge('D', 'G');\r\n        graph.addEdge('D', 'H');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('B', 'F');\r\n        graph.addEdge('E', 'I');\r\n        console.log('********* printing graph ***********');\r\n        console.log(graph.toString());\r\n        console.log(graph.getAdjList().get('B'));\r\n        const printVertex = (value) => console.log('Visited vertex: ' + value);\r\n        console.log('start from A :');\r\n        breadthFirstSearch(graph, myVertices[0], printVertex);\r\n        console.log('start from D :');\r\n        breadthFirstSearch(graph, 'D', printVertex);\r\n        console.log('********* sorthest path from A- BFS ***********');\r\n        const shortestPathA = BFS(graph, myVertices[0]);\r\n        console.log(shortestPathA.distances);\r\n        console.log(shortestPathA.predecessors);\r\n        console.log('********* sorthest path from D- BFS ***********');\r\n        const shortestPathD = BFS(graph, 'D');\r\n        console.log(shortestPathD.distances);\r\n        console.log(shortestPathD.predecessors);\r\n        console.log('********* from A to all other vertices ***********');\r\n        const fromVertex = myVertices[0];\r\n        for (let i = 1; i < myVertices.length; i++) {\r\n            const toVertex = myVertices[i];\r\n            const path = new Stack();\r\n            for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v])\r\n                path.push(v);\r\n            path.push(fromVertex);\r\n            let s = path.pop();\r\n            while (!path.isEmpty())\r\n                s += ' _ ' + path.pop();\r\n            console.log(s);\r\n        }\r\n        console.log('********* dfs with callback ***********');\r\n        depthFirstSearch(graph, printVertex);\r\n        console.log('********* topological sort - DFS ***********');\r\n        graph = new Graph();\r\n        for (let i = 0; i < myVertices.length; i++)\r\n            graph.addVertex(myVertices[i]);\r\n        graph.addEdge('A', 'B');\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('C', 'D');\r\n        graph.addEdge('C', 'G');\r\n        graph.addEdge('D', 'G');\r\n        graph.addEdge('D', 'H');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('B', 'F');\r\n        graph.addEdge('E', 'I');\r\n        let result = DFS(graph);\r\n        console.log('discovery', result.discovery);\r\n        console.log('finished', result.finished);\r\n        console.log('predecessors', result.predecessors);\r\n        graph = new Graph(true);\r\n        myVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\r\n        for (let i = 0; i < myVertices.length; i++) {\r\n            graph.addVertex(myVertices[i]);\r\n        }\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('B', 'D');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('C', 'F');\r\n        graph.addEdge('F', 'E');\r\n        result = DFS(graph);\r\n        console.log('discovery', result.discovery);\r\n        console.log('finished', result.finished);\r\n        console.log('predecessors', result.predecessors);\r\n        const fTimes = result.finished;\r\n        let s = '';\r\n        for (let count = 0; count < myVertices.length; count++) {\r\n            let max = 0;\r\n            let maxName = null;\r\n            for (let i = 0; i < myVertices.length; i++) {\r\n                if (fTimes[myVertices[i]] > max) {\r\n                    max = fTimes[myVertices[i]];\r\n                    maxName = myVertices[i];\r\n                }\r\n            }\r\n            s += ' _ ' + maxName;\r\n            delete fTimes[maxName];\r\n        }\r\n        console.log(s);\r\n        const graphM = [\r\n            [0, 2, 4, 0, 0, 0],\r\n            [0, 0, 1, 4, 2, 0],\r\n            [0, 0, 0, 0, 3, 0],\r\n            [0, 0, 0, 0, 0, 2],\r\n            [0, 0, 0, 3, 0, 2],\r\n            [0, 0, 0, 0, 0, 0]\r\n        ];\r\n        console.log(\"********* Dijkstra's Algorithm - Shortest Path ***********\");\r\n        console.log(` \r\n        [0, 2, 4, 0, 0, 0],\r\n        [0, 0, 1, 4, 2, 0],\r\n        [0, 0, 0, 0, 3, 0],\r\n        [0, 0, 0, 0, 0, 2],\r\n        [0, 0, 0, 3, 0, 2],\r\n        [0, 0, 0, 0, 0, 0]`);\r\n        let dist = dijkstra(graphM, 0);\r\n        dist.forEach((v, i) => { console.log(i + '\\t\\t' + v); });\r\n        let distPath = dijkstraWithPath(graphM, 0);\r\n        distPath.forEach((v, i) => console.log(v + '\\t\\t'));\r\n        console.log('********* Floyd-Warshall Algorithm - All-Pairs Shortest Path ***********');\r\n        const INF = Infinity;\r\n        const graphN = [\r\n            [INF, 2, 4, INF, INF, INF],\r\n            [INF, INF, 1, 4, 2, INF],\r\n            [INF, INF, INF, INF, 3, INF],\r\n            [INF, INF, INF, INF, INF, 2],\r\n            [INF, INF, INF, 3, INF, 2],\r\n            [INF, INF, INF, INF, INF, INF]\r\n        ];\r\n        let distN = floydWarshall(graphN);\r\n        let pathN = floydWarshallWithPath(graphN);\r\n        const graphO = [\r\n            [INF, 3, 8, INF, -4],\r\n            [INF, INF, INF, 1, 7],\r\n            [INF, 4, INF, INF, INF],\r\n            [2, INF, -5, INF, INF],\r\n            [INF, INF, INF, 6, INF]\r\n        ];\r\n        let distO = floydWarshall(graphO);\r\n        let pathO = floydWarshallWithPath(graphO);\r\n        let printMatrix = (m) => {\r\n            let s = '';\r\n            for (let i = 0; i < m.length; ++i) {\r\n                s = '';\r\n                for (var j = 0; j < m.length; ++j) {\r\n                    if (m[i][j] === INF) {\r\n                        s += ' ';\r\n                        s += 'INF ';\r\n                    }\r\n                    else {\r\n                        if (m[i][j] >= 0)\r\n                            s += ' ';\r\n                        s += m[i][j] + '   ';\r\n                    }\r\n                }\r\n                console.log(s);\r\n            }\r\n        };\r\n        console.log('\\n');\r\n        console.log('floyd dist');\r\n        printMatrix(distN);\r\n        console.log('\\n');\r\n        printMatrix(distO);\r\n        console.log('\\n');\r\n        console.log('floyd path');\r\n        printMatrix(pathN);\r\n        console.log('\\n');\r\n        printMatrix(pathO);\r\n        const gt = (name) => {\r\n            return this.owner.getChildByName(name);\r\n        };\r\n        let mm = [\r\n            [gt('m00'), gt('m10'), gt('m20'), gt('m30'), gt('m40'), gt('m50')],\r\n            [gt('m01'), gt('m11'), gt('m21'), gt('m31'), gt('m41'), gt('m51')],\r\n            [gt('m02'), gt('m12'), gt('m22'), gt('m32'), gt('m42'), gt('m52')],\r\n            [gt('m03'), gt('m13'), gt('m23'), gt('m33'), gt('m43'), gt('m53')],\r\n            [gt('m04'), gt('m14'), gt('m24'), gt('m34'), gt('m44'), gt('m54')],\r\n            [gt('m05'), gt('m15'), gt('m25'), gt('m35'), gt('m45'), gt('m55')]\r\n        ];\r\n        let kl = [];\r\n        let il = [];\r\n        let jl = [];\r\n        for (let k = 0; k < 6; k++)\r\n            for (let i = 0; i < 6; i++)\r\n                for (let j = 0; j < 6; j++) {\r\n                    kl.push(i, k);\r\n                    il.push(k, j);\r\n                    jl.push(i, j);\r\n                }\r\n        Laya.timer.loop(300, this, () => {\r\n            let a = 0, b = 0;\r\n            if (kl.length > 0) {\r\n                a = kl.shift(), b = kl.shift();\r\n                mm[a][b]['texture'] = 'test/t1.png';\r\n            }\r\n            if (il.length > 0) {\r\n                a = il.shift(), b = il.shift();\r\n                mm[a][b]['texture'] = 'test/c1.png';\r\n            }\r\n            if (jl.length > 0) {\r\n                a = jl.shift(), b = jl.shift();\r\n                mm[a][b]['texture'] = 'test/tra.png';\r\n            }\r\n        });\r\n        const graphP = [\r\n            [0, 2, 4, 0, 0, 0],\r\n            [2, 0, 2, 4, 2, 0],\r\n            [4, 2, 0, 0, 3, 0],\r\n            [0, 4, 0, 0, 3, 2],\r\n            [0, 2, 3, 3, 0, 2],\r\n            [0, 0, 0, 2, 2, 0]\r\n        ];\r\n        console.log(\"********* Prim's Algorithm - Minimum Spanning Tree ***********\");\r\n        const pathP = prim(graphP);\r\n        console.log('Edge   Weight');\r\n        for (let i = 1; i < graphP.length; i++)\r\n            console.log(pathP[i] + ' - ' + i + '   ' + graphP[i][pathP[i]]);\r\n    }\r\n}\r\n",
  "references": [
    "D:/widgets/LayaDataStructuresAlgorithms/libs/Laya.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/libs/laya/components/Script.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/libs/laya/display/Scene.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/breadth-first-search.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/depth-first-search.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/dijkstra.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/Floyd-warshall.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/prim.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/data_structures/Graph.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/data_structures/Stack.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/GameConfig.ts"
  ]
}
