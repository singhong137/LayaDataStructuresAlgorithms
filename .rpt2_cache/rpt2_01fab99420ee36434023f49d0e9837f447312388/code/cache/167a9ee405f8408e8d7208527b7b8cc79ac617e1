{
  "code": "import { Script } from \"laya/components/Script\";\r\nimport { BFS, breadthFirstSearch } from \"../algorithms/graph/breadth-first-search\";\r\nimport { depthFirstSearch, DFS } from \"../algorithms/graph/depth-first-search\";\r\nimport { dijkstra, dijkstraWithPath } from \"../algorithms/graph/dijkstra\";\r\nimport Graph from \"../data_structures/Graph\";\r\nimport { Stack } from \"../data_structures/Stack\";\r\nexport default class GraphTest extends Script {\r\n    constructor() {\r\n        super();\r\n    }\r\n    onEnable() {\r\n        console.log('GraphTest---');\r\n        let graph = new Graph();\r\n        let myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\r\n        for (let i = 0; i < myVertices.length; i++)\r\n            graph.addVertex(myVertices[i]);\r\n        graph.addEdge('A', 'B');\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('C', 'D');\r\n        graph.addEdge('C', 'G');\r\n        graph.addEdge('D', 'G');\r\n        graph.addEdge('D', 'H');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('B', 'F');\r\n        graph.addEdge('E', 'I');\r\n        console.log('********* printing graph ***********');\r\n        console.log(graph.toString());\r\n        console.log(graph.getAdjList().get('B'));\r\n        const printVertex = (value) => console.log('Visited vertex: ' + value);\r\n        console.log('start from A :');\r\n        breadthFirstSearch(graph, myVertices[0], printVertex);\r\n        console.log('start from D :');\r\n        breadthFirstSearch(graph, 'D', printVertex);\r\n        console.log('********* sorthest path from A- BFS ***********');\r\n        const shortestPathA = BFS(graph, myVertices[0]);\r\n        console.log(shortestPathA.distances);\r\n        console.log(shortestPathA.predecessors);\r\n        console.log('********* sorthest path from D- BFS ***********');\r\n        const shortestPathD = BFS(graph, 'D');\r\n        console.log(shortestPathD.distances);\r\n        console.log(shortestPathD.predecessors);\r\n        console.log('********* from A to all other vertices ***********');\r\n        const fromVertex = myVertices[0];\r\n        for (let i = 1; i < myVertices.length; i++) {\r\n            const toVertex = myVertices[i];\r\n            const path = new Stack();\r\n            for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v])\r\n                path.push(v);\r\n            path.push(fromVertex);\r\n            let s = path.pop();\r\n            while (!path.isEmpty())\r\n                s += ' _ ' + path.pop();\r\n            console.log(s);\r\n        }\r\n        console.log('********* dfs with callback ***********');\r\n        depthFirstSearch(graph, printVertex);\r\n        console.log('********* topological sort - DFS ***********');\r\n        graph = new Graph();\r\n        for (let i = 0; i < myVertices.length; i++)\r\n            graph.addVertex(myVertices[i]);\r\n        graph.addEdge('A', 'B');\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('C', 'D');\r\n        graph.addEdge('C', 'G');\r\n        graph.addEdge('D', 'G');\r\n        graph.addEdge('D', 'H');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('B', 'F');\r\n        graph.addEdge('E', 'I');\r\n        let result = DFS(graph);\r\n        console.log('discovery', result.discovery);\r\n        console.log('finished', result.finished);\r\n        console.log('predecessors', result.predecessors);\r\n        graph = new Graph(true);\r\n        myVertices = ['A', 'B', 'C', 'D', 'E', 'F'];\r\n        for (let i = 0; i < myVertices.length; i++) {\r\n            graph.addVertex(myVertices[i]);\r\n        }\r\n        graph.addEdge('A', 'C');\r\n        graph.addEdge('A', 'D');\r\n        graph.addEdge('B', 'D');\r\n        graph.addEdge('B', 'E');\r\n        graph.addEdge('C', 'F');\r\n        graph.addEdge('F', 'E');\r\n        result = DFS(graph);\r\n        console.log('discovery', result.discovery);\r\n        console.log('finished', result.finished);\r\n        console.log('predecessors', result.predecessors);\r\n        const fTimes = result.finished;\r\n        let s = '';\r\n        for (let count = 0; count < myVertices.length; count++) {\r\n            let max = 0;\r\n            let maxName = null;\r\n            for (let i = 0; i < myVertices.length; i++) {\r\n                if (fTimes[myVertices[i]] > max) {\r\n                    max = fTimes[myVertices[i]];\r\n                    maxName = myVertices[i];\r\n                }\r\n            }\r\n            s += ' _ ' + maxName;\r\n            delete fTimes[maxName];\r\n        }\r\n        console.log(s);\r\n        const graphM = [\r\n            [0, 2, 4, 0, 0, 0],\r\n            [0, 0, 1, 4, 2, 0],\r\n            [0, 0, 0, 0, 3, 0],\r\n            [0, 0, 0, 0, 0, 2],\r\n            [0, 0, 0, 3, 0, 2],\r\n            [0, 0, 0, 0, 0, 0]\r\n        ];\r\n        console.log(\"********* Dijkstra's Algorithm - Shortest Path ***********\");\r\n        console.log(` \r\n        [0, 2, 4, 0, 0, 0],\r\n        [0, 0, 1, 4, 2, 0],\r\n        [0, 0, 0, 0, 3, 0],\r\n        [0, 0, 0, 0, 0, 2],\r\n        [0, 0, 0, 3, 0, 2],\r\n        [0, 0, 0, 0, 0, 0]`);\r\n        let dist = dijkstra(graphM, 0);\r\n        dist.forEach((v, i) => { console.log(i + '\\t\\t' + v); });\r\n        let distPath = dijkstraWithPath(graphM, 0);\r\n        distPath.forEach((v, i) => console.log(v + '\\t\\t'));\r\n    }\r\n}\r\n",
  "references": [
    "D:/widgets/LayaDataStructuresAlgorithms/libs/laya/components/Script.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/breadth-first-search.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/depth-first-search.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/algorithms/graph/dijkstra.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/data_structures/Graph.ts",
    "D:/widgets/LayaDataStructuresAlgorithms/src/data_structures/Stack.ts"
  ]
}
